最近一口气读完了二百多页的《Elegant Objects》。可能因为整理自博客所以排版一般，而且才二百多页定价却40多刀。但读过之后发现超值，甚至还想去买第二卷。作者观点大多比较激进，对自己的理念异常坚定，所以经常使用诸如“绝对不要使用XXX”、“记住XXX，就这样，句号”。但作者绝不故弄玄虚，在批判之后，一定会给出自己的建议和代码示例。除去个别章节个人觉得很有争议，大部分内容读过之后都是很震撼的。另外原书观点较为零散，为了方便感兴趣的同学继续阅读学习，本文重点部分都标注了与原书章节的对应。

---

## 1.面向对象思想



### 1.1 不要像机器一样思考



### 1.2 一切都为了维护性





### 1.3 面向对象的癌症





## 2.概念的封装

对象不是一堆由我们调用者决定调用顺序的函数集合，依次调用操作其内部封装的数据。作者反复用拟人的方式强调，这种指手画脚地方式是对“别人”的不尊重。我们去餐厅点菜，不会跟厨师说你得先做这个再做那个，这样做出来才好吃。现实中我们直接说，请给我来一份这个菜，厨师会自己决定如何烹饪。跟一个对象打交道也是如此，**对象是一个自洽的、能自己做决定并自己行动的实体**，就像一个能自给自足（self-sufficient）的生物一样。所以说，**对象与对象之间相互“尊重信任”的关系是面向对象思想的核心**。

### 2.1 设计者：隐藏好你的抽象

从对象设计者角度，要自重，不要泄漏你的实现细节，不要泄漏任何内部抽象。从这个角度来说，setter/getter也是邪恶的（原书3.5节）。你可能会说，setter/getter不是远好于直接暴露成员变量吗？而且它还是Java Bean的标准，我们还可以在里面添加数据验证、甚至改变存储内容方式等逻辑。但这都不重要，重要的是对于调用者来说这与直接的数据访问没什么区别。比如下面`Cash`类中如果加上一个`getDollars()`方法，那就好像让调用者对自己说：“去成员数据里找，看看有没有一个叫`dollars`的，把它返回给我”。而`dollars()`则会好一些，仿佛在说：“请告诉我你有多少美元？”（另可参考原书的2.4节 Choose method names carefully，作者对方法起名的见解）。

此外也不要返回`NULL`造成空指针异常，失去调用者对你的信任（原书4.1节 Never return NULL）。返回`NULL`的最常见情况就是找不到调用者想要的对象，那么可选的其他方式有返回空列表/集合，如果只是要返回一个单一对象的话则可采用空对象设计模式，或者在必要时抛出异常。更深层的原因是`NULL`不应该出现在面向对象的世界里（原书3.3节 Never accept NULL arguments）。

也不要因为方便而对外提供成员常量，比如`public static final String CRLF = "\r\n"`，看似很常见却破坏了面向对象的理念（原书2.5节 Don't use public constants）。下面将这部分逻辑封装到`CRLFString`类中，我们再也不用担心明天要为不同平台添加不同的换行符了。但这会导致很多类不是么，参见第三部分关于短小而简单的类设计理念的讨论。

```java
class CRLFString {
    private final String src;
    CRLFString(String src) {
        this.src = src;
    }
    String toString() {
        if (/* this is windows */) {
        	//...
        }
        return String.format("%s\r\n", src);
    }
}
```

### 2.2 使用者：Show Your Respect

从使用者角度，不要去偷窥，比如利用反射技术在运行时获取对象内部的信息，比如最常用的`instanceof`判断对象是否是某个具体的子类等等（原书3.7节 Avoid type introspection and casting）。可能你会说你很少用反射，也可以尽量不用，但单元测试里的mock技术是无人不知、无人不晓的。mock难道不是很好的技术吗？现在已经有了很多非常棒的mock框架。

```java
class Cash {
    private final Exchange exchange;
    private final int cents;
    public Cash(Exchange exchange, int cents) {
        this.exchange = exchange;
        this.cents = cents;
    }
    public Cash in(String currency) {
        return new Cash(
        	exchange,
        	cents * exchange.rate("USD", currency)
        );
    }
}

Exchange exchange = Mockito.mock(Exchange.class);
Mockito.doReturn(1.15).when(exchange).rate("USD", "EUR");
Cash dollar = new Cash(exchange, 500);
Cash euro = dollar.in("EUR");
assert "5.75".equals(euro.toString());
```

经过本文前面的论述，你应该一眼就能看出问题了。我们读了被测试类`Cash`的源代码，然后去控制它依赖的Exchange的行为。这是严重的冒犯啊！**我们没有任何权利去假定别人的内部抉择，我们唯一能做的就是确定如何与`Cash`交互，而不是干涉`Cash`与别人的交互**。于是作者提出不要mock，而是提供`Fake`类给所有测试类共享使用（原书2.8节 Don't mock; use fakes）。所以`Fake`类可能比本尊更加复杂和强大。

```java
interface Exchange {
    float rate(String origin, String target);
    final class Fake implements Exchange {
        @Override
        float rate(String origin, String target) {
            return 1.2345;
        }
    }
}
```

### 2.3 观念转变：对象为王

在面向过程的时代，代码为王，代码指挥一切，数据只是被动地等待被处理。而面向对象将其反转，对象现在是王，代码变成了二等公民。之前起名一直是个难题，不管是给类、方法还是变量，可作者却不这样认为。作者说道：看看对象封装了什么数据，然后为这个（概念）起个名字，就是这样简单。所以如果你的类名中含有动作，或者动作-er，那就说明你潜意识中还是在按照面向过程的方式思考（原书1.1节 Never use -er names）。

```java
class CashFormatter {
    private int dollars;
    CashFormatter(int dollars) {
        this.dollars = dollars;
    }
    public String format() {
        return String.format("$ %d", this.dollars);
    }
}
```

`CashFormatter`这种类我们见得太多了，Manager、Controller、Helper、Handler、Writer、Reader、Converter、Validator、Router、Dispatcher、Observer、Listener、Encoder、Decoder。如果谁说自己从来没起过这样的名字，那还真难以置信。因为不只我们，各种优秀的开源框架、设计模式里也在用这样的名字。但《Elegant Objects》一书的作者指出：`Cash`类就**是**它封装的`dollars`，而不是`format()`方法，**它就是它所封装的数据**！

```java
class Cash {
    //...
    public String usd() {
        return String.format("$ %d", this.dollars);
    }
}
```



---

## 3.短小简洁的力量

### 3.1 英语和汉语 

更多更小的类，意味着职责、概念、含义的分散，作者举了一个形象的比喻（原书2.5节 Don't use public constants）：英语里的单词越多（并且不是同义词），也就意味着你的文字可读性更高。相反则说明一些词有很多含义，并且被反复使用着，造成可读性很低。比如下面两句话，可读性孰高孰低一目了然。

```
My cat likes to eat fish and drink milk.
My thing likes to eat that thing and drink another thing. 
```

就好比公认难学的汉语，有很多的一词多义、一字多音，同样一个字或词。在不同的语境下有不同的含义甚至发音，于是让想学汉语的老外们望而却步。面向对象的语言世界也是如此，**一个对象太过灵活、太过强大（一词多义），也就意味着使用的难度更大。一个对象能够出现在各种地方（用在各种语境有不同含义），就需要使用者对其有非常深刻的了解（像母语一样）**。

### 3.2 规约越少越好

规约，即接口中我们要求实现者实现的公有方法。规约少则有以下几个好处（原书3.1节 Expose fewer than five public methods）：

1. 出问题时更容易定位，因为对象只有这几个入口
2. 更可能达到高内聚，因为我们有更大机会让这几个方法都围绕数据
3. 用例场景更少，意味着更容易测试，测试类也更小

但有时我们想提供多个重载方法，像多个构造器一样让使用者更加方便，那应该怎么办呢？类似供测试类共享的`Fake`类一样，我们还可以提供一个`Smart`类（原书2.9节 Keep interface short; use smarts）。

```java
interface Exchange {
    float rate(String target);
    float rate(String source, String target);
}

interface Exchange {
    float rate(String source, String target);
    
    final class Smart {
        private final Exchange origin;
        public float toUsd(String source) {
            return origin.rate(source, "USD");
        }
        public float eurToUsd() {
            return toUsd("EUR");
        }
    }
}

float rate = new Exchange.Smart(new NYSE()).toUsd("EUR");
float rate = new Exchange.Smart(new NYSE()).eurToUsd();
```

### 3.3 构造器与私有方法，多些没问题

与规约不同，构造器和私有方法多一些则没有任何问题。不能说越多越好，但绝对没有公有方法的“危害”那样大。一个有20个公共接口的类绝对是有问题的，但一个只有两三个公共方法外加5个构造器和10个私有方法的对象，可能刚刚好。为什么会这样呢？因为你提供的构造器越多，你就提供了越多的灵活性给使用者（原书1.2节 Make one constructor primary）。同理，越多私有方法，意味着你的逻辑比较复杂，所以拆分成不同的私有方法来让整体更为清晰。而如前所述，公有方法却完全不是这个样子，它意味着对使用者更多的约束、更多更繁杂的使用场景、很可能更低的内聚性等。

所以说，不用担心简洁的类设计导致类数量的爆炸，也不用担心每个类都没什么内容。多提供一些构造方法，将公有方法的逻辑写仔细了，这样的内容就已经足够一个类文件去承载了。比如下面的`Cash`类的各种构造器。

```java
new Cash(30);
new Cash("$29.95");
new Cash(29.95d);
new Cash(29.95f);
new Cash(29.95, "USD");
```



---

## 4.可变世界中的不可变性



---

## 5.声明式编程

作者理想中的软件，除了最底层的细节，中上层是没有操作符、语句，只有对象的初始化和构造器。

贫血模型



### 5.1 顺序化思考

我们每天都在进行着顺序化的思考，比如你要去ATM取钱，第一步是查询最近的银行ATM在哪，第二步去输入密码取钱等等。下面则是一个典型的顺序化代码，为了求两数之中的最大值，先比较它们，如果A大则返回A，否则返回B。从这段代码，我们能清晰地在脑袋里想象出整个代码流程。如果你对汇编很熟悉的话，还是看出CPU是如何执行每条指令的（排除编译器优化的复杂性）。

```java
int max(int a, int b) {
    if (a > b) {
        return a;
    }
    return b;
}
```

下面是一段LISP中的最大值函数代码，你还能看出它是如何开始执行、如何结束的吗？也许这个简单的例子难不倒你，也许你对解释器在现代计算机上的实现也了如指掌。但这并不重要，重要的是：**从代码字面到实际执行流程不再是简单的映射**。也就是说，我们隐藏了具体的“过程式”细节，达到了“声明式”的抽象层次。

```lisp
(defun max (a b)
	(if (> a b) a b))
```

### 5.2 面向对象思考

在面向对象的世界里，我们同样可以做到LISP能做的事，关键就是面向对象的思考方式。我们定义谁是谁，让它们根据需要自己交互。**我们定义概念和概念之间的关系**。比如下面的`Max`类，在使用者的层次上，我们没有说如何求最大值，**我们没有写任何的语句、指令或操作符，我们只是定义了5、9和x三者间的关系，即x是5和9之间的最大值**。

```java
class Max implements Number {
    private final Number a;
    private final Number b;
    public Max(Number left, Number right) {
        this.a = left;
        this.b = right;
    }
	//...
}

Number x = new Max(5, 9);
```

可是不管怎样隐藏，最终在某个角落，我们不是还要去用if语句、大于小于比较符，写“过程式”的代码吗？这也正是我的疑问。

### 5.2 函数式编程





---

## 后记：面向对象的理想国

通过前面的讲解分析，相信大家心中对“什么样的对象才是优雅的？”的问题有了自己的答案。一个优雅对象具备了诸多好品质，比如本文中提到的自给自足的封装、短小简洁的类和方法、不可变的状态、声明式编程风格等等。

+ 每个对象都是一个概念的完美封装，能够独立地完成任务，并且多一点少一点内容都不合适。
+ 每个对象又是不可变的，对象初始化就创建好，之后也不会改变，不会再有神秘的并发问题。
+ 对象间通过声明式方式组合到一起，达到比较高的抽象层次。

当然，也许你并不需要完全遵循本文或者原书的观点，但如果通过文本能激发你的思考，那也就算是一大收获。